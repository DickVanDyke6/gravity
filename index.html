<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Gravity Sandbox</title>
<style>
  body {
    margin: 0;
    background: #111;
    color: #eee;
    font-family: sans-serif;
    overflow: hidden;
  }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 8px;
  }
  label { display: block; margin-top: 5px; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="ui">
  <button id="clear">Clear Projectiles</button>
  <label>
    <input type="checkbox" id="collisions">
    Enable Collisions
  </label>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
resize();
window.addEventListener("resize", resize);

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}

const G = 1200;
const planet = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  r: 60,
  mass: 5000
};

const projectiles = [];
let collisionsEnabled = false;

document.getElementById("collisions").onchange = e =>
  collisionsEnabled = e.target.checked;

document.getElementById("clear").onclick = () =>
  projectiles.length = 0;

// -----------------------------
// Input (drag to launch)
// -----------------------------
let dragging = false;
let dragStart = null;
let dragCurrent = null;

canvas.addEventListener("mousedown", e => {
  dragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener("mousemove", e => {
  if (dragging) dragCurrent = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener("mouseup", e => {
  dragging = false;
  if (!dragStart || !dragCurrent) return;

  const vx = (dragStart.x - dragCurrent.x) * 0.05;
  const vy = (dragStart.y - dragCurrent.y) * 0.05;

  projectiles.push({
    x: dragStart.x,
    y: dragStart.y,
    vx, vy,
    r: 8,
    mass: 1
  });

  dragStart = dragCurrent = null;
});

// -----------------------------
// Physics
// -----------------------------
function applyGravity(p) {
  const dx = planet.x - p.x;
  const dy = planet.y - p.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist === 0) return;

  const force = G * planet.mass * p.mass / (dist * dist);
  const ax = force * dx / dist / p.mass;
  const ay = force * dy / dist / p.mass;

  p.vx += ax;
  p.vy += ay;
}

// ---- CENTRAL COLLISION (UNCHANGED) ----
function resolvePlanetCollision(p) {
  const dx = p.x - planet.x;
  const dy = p.y - planet.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const minDist = planet.r + p.r;

  if (dist >= minDist || dist === 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  // snap to surface
  p.x = planet.x + nx * minDist;
  p.y = planet.y + ny * minDist;

  const vn = p.vx * nx + p.vy * ny;
  const tx = -ny;
  const ty = nx;
  const vt = p.vx * tx + p.vy * ty;

  const restitution = 0.6;
  const friction = 0.85;

  p.vx = -vn * restitution * nx + vt * friction * tx;
  p.vy = -vn * restitution * ny + vt * friction * ty;
}

// ---- PROJECTILEâ€“PROJECTILE (PLANET-STYLE) ----
function resolveProjectileCollision(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const minDist = a.r + b.r;
  if (dist >= minDist || dist === 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  // positional correction (gentle)
  const overlap = minDist - dist;
  const correction = overlap * 0.5;
  a.x -= nx * correction;
  a.y -= ny * correction;
  b.x += nx * correction;
  b.y += ny * correction;

  // relative velocity
  const rvx = a.vx - b.vx;
  const rvy = a.vy - b.vy;

  const vn = rvx * nx + rvy * ny;
  if (vn > 0) return;

  const tx = -ny;
  const ty = nx;
  const vt = rvx * tx + rvy * ty;

  const restitution = 0.6;
  const friction = 0.85;

  const impulseN = -vn * restitution;
  const im1 = 1 / a.mass;
  const im2 = 1 / b.mass;
  const impulse = impulseN / (im1 + im2);

  const ix = impulse * nx;
  const iy = impulse * ny;

  a.vx += ix * im1;
  a.vy += iy * im1;
  b.vx -= ix * im2;
  b.vy -= iy * im2;

  // tangential friction (planet-style)
  const frictionImpulse = vt * friction * 0.1;
  a.vx -= frictionImpulse * tx;
  a.vy -= frictionImpulse * ty;
  b.vx += frictionImpulse * tx;
  b.vy += frictionImpulse * ty;
}

// -----------------------------
// Loop
// -----------------------------
function update() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // planet
  ctx.beginPath();
  ctx.arc(planet.x, planet.y, planet.r, 0, Math.PI*2);
  ctx.fillStyle = "#3a7";
  ctx.fill();

  for (const p of projectiles) {
    applyGravity(p);
    p.x += p.vx;
    p.y += p.vy;

    if (collisionsEnabled)
      resolvePlanetCollision(p);
  }

  if (collisionsEnabled) {
    for (let i=0;i<projectiles.length;i++) {
      for (let j=i+1;j<projectiles.length;j++) {
        resolveProjectileCollision(projectiles[i], projectiles[j]);
      }
    }
  }

  // draw projectiles
  for (const p of projectiles) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fillStyle = "#ddd";
    ctx.fill();
  }

  // drag preview
  if (dragging && dragStart && dragCurrent) {
    ctx.beginPath();
    ctx.moveTo(dragStart.x, dragStart.y);
    ctx.lineTo(dragCurrent.x, dragCurrent.y);
    ctx.strokeStyle = "#f55";
    ctx.stroke();
  }

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>