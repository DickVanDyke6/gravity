<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Gravity Sandbox</title>
<style>
  body {
    margin: 0;
    background: #111;
    color: #eee;
    font-family: sans-serif;
    overflow: hidden;
  }
  canvas {
    display: block;
  }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 10;
    background: rgba(0,0,0,0.75);
    padding: 10px;
    border-radius: 8px;
  }
  label {
    display: block;
    margin-top: 6px;
    user-select: none;
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="ui">
  <button id="clear">Clear Projectiles</button>
  <label>
    <input type="checkbox" id="collisions">
    Enable Collisions
  </label>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
window.addEventListener("resize", resize);

// ----------------- World -----------------
const G = 1200;

const planet = {
  x: () => canvas.width / 2,
  y: () => canvas.height / 2,
  r: 60,
  mass: 5000
};

const projectiles = [];
let collisionsEnabled = false;

document.getElementById("collisions").onchange =
  e => collisionsEnabled = e.target.checked;

document.getElementById("clear").onclick =
  () => projectiles.length = 0;

// ----------------- Input (mouse + touch) -----------------
let dragging = false;
let dragStart = null;
let dragCurrent = null;

function getPos(e) {
  if (e.touches) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

function startDrag(e) {
  dragging = true;
  dragStart = getPos(e);
  dragCurrent = dragStart;
}

function moveDrag(e) {
  if (!dragging) return;
  dragCurrent = getPos(e);
}

function endDrag(e) {
  if (!dragging) return;
  dragging = false;

  const vx = (dragStart.x - dragCurrent.x) * 0.05;
  const vy = (dragStart.y - dragCurrent.y) * 0.05;

  projectiles.push({
    x: dragStart.x,
    y: dragStart.y,
    vx, vy,
    r: 8,
    mass: 1
  });

  dragStart = dragCurrent = null;
}

canvas.addEventListener("mousedown", startDrag);
canvas.addEventListener("mousemove", moveDrag);
canvas.addEventListener("mouseup", endDrag);

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  startDrag(e);
}, { passive: false });

canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  moveDrag(e);
}, { passive: false });

canvas.addEventListener("touchend", e => {
  e.preventDefault();
  endDrag(e);
}, { passive: false });

// ----------------- Physics -----------------
function applyGravity(p) {
  const dx = planet.x() - p.x;
  const dy = planet.y() - p.y;
  const dist = Math.hypot(dx, dy);
  if (dist === 0) return;

  const force = G * planet.mass / (dist * dist);
  p.vx += force * dx / dist;
  p.vy += force * dy / dist;
}

// Planet collision (unchanged logic)
function resolvePlanetCollision(p) {
  const dx = p.x - planet.x();
  const dy = p.y - planet.y();
  const dist = Math.hypot(dx, dy);
  const minDist = planet.r + p.r;
  if (dist >= minDist || dist === 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  p.x = planet.x() + nx * minDist;
  p.y = planet.y() + ny * minDist;

  const vn = p.vx * nx + p.vy * ny;
  const tx = -ny, ty = nx;
  const vt = p.vx * tx + p.vy * ty;

  const restitution = 0.6;
  const friction = 0.85;

  p.vx = -vn * restitution * nx + vt * friction * tx;
  p.vy = -vn * restitution * ny + vt * friction * ty;
}

// Projectileâ€“projectile (same logic style)
function resolveProjectileCollision(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.hypot(dx, dy);
  const minDist = a.r + b.r;
  if (dist >= minDist || dist === 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const overlap = minDist - dist;
  a.x -= nx * overlap * 0.5;
  a.y -= ny * overlap * 0.5;
  b.x += nx * overlap * 0.5;
  b.y += ny * overlap * 0.5;

  const rvx = a.vx - b.vx;
  const rvy = a.vy - b.vy;
  const vn = rvx * nx + rvy * ny;
  if (vn > 0) return;

  const tx = -ny, ty = nx;
  const vt = rvx * tx + rvy * ty;

  const restitution = 0.6;
  const friction = 0.85;

  const impulse = -vn / (1/a.mass + 1/b.mass);
  const ix = impulse * nx;
  const iy = impulse * ny;

  a.vx += ix / a.mass;
  a.vy += iy / a.mass;
  b.vx -= ix / b.mass;
  b.vy -= iy / b.mass;

  a.vx -= vt * friction * tx * 0.05;
  a.vy -= vt * friction * ty * 0.05;
  b.vx += vt * friction * tx * 0.05;
  b.vy += vt * friction * ty * 0.05;
}

// ----------------- Loop -----------------
function update() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // planet (blue again)
  ctx.beginPath();
  ctx.arc(planet.x(), planet.y(), planet.r, 0, Math.PI*2);
  ctx.fillStyle = "#2a6cff";
  ctx.fill();

  for (const p of projectiles) {
    applyGravity(p);
    p.x += p.vx;
    p.y += p.vy;
    if (collisionsEnabled) resolvePlanetCollision(p);
  }

  if (collisionsEnabled) {
    for (let i=0;i<projectiles.length;i++) {
      for (let j=i+1;j<projectiles.length;j++) {
        resolveProjectileCollision(projectiles[i], projectiles[j]);
      }
    }
  }

  for (const p of projectiles) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fillStyle = "#ddd";
    ctx.fill();
  }

  if (dragging && dragStart && dragCurrent) {
    ctx.beginPath();
    ctx.moveTo(dragStart.x, dragStart.y);
    ctx.lineTo(dragCurrent.x, dragCurrent.y);
    ctx.strokeStyle = "#f55";
    ctx.stroke();
  }

  requestAnimationFrame(update);
}
update();
</script>
</body>
</html>